{"ast":null,"code":"import * as THREE from 'three';\nconst _instanceLocalMatrix = /*@__PURE__*/new THREE.Matrix4();\nconst _instanceWorldMatrix = /*@__PURE__*/new THREE.Matrix4();\nconst _instanceIntersects = [];\nconst _mesh = /*@__PURE__*/new THREE.Mesh();\nclass Position extends THREE.Group {\n  constructor() {\n    super();\n    this.color = new THREE.Color('white');\n    this.instance = {\n      current: undefined\n    };\n    this.instanceKey = {\n      current: undefined\n    };\n  } // This will allow the virtual instance have bounds\n\n  get geometry() {\n    var _this$instance$curren;\n    return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;\n  } // And this will allow the virtual instance to receive events\n\n  raycast(raycaster, intersects) {\n    const parent = this.instance.current;\n    if (!parent) return;\n    if (!parent.geometry || !parent.material) return;\n    _mesh.geometry = parent.geometry;\n    const matrixWorld = parent.matrixWorld;\n    let instanceId = parent.userData.instances.indexOf(this.instanceKey); // If the instance wasn't found or exceeds the parents draw range, bail out\n\n    if (instanceId === -1 || instanceId > parent.count) return; // calculate the world matrix for each instance\n\n    parent.getMatrixAt(instanceId, _instanceLocalMatrix);\n    _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n    _mesh.matrixWorld = _instanceWorldMatrix;\n    _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n    for (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n      const intersect = _instanceIntersects[i];\n      intersect.instanceId = instanceId;\n      intersect.object = this;\n      intersects.push(intersect);\n    }\n    _instanceIntersects.length = 0;\n  }\n}\nexport { Position };","map":{"version":3,"names":["THREE","_instanceLocalMatrix","Matrix4","_instanceWorldMatrix","_instanceIntersects","_mesh","Mesh","Position","Group","constructor","color","Color","instance","current","undefined","instanceKey","geometry","_this$instance$curren","raycast","raycaster","intersects","parent","material","matrixWorld","instanceId","userData","instances","indexOf","count","getMatrixAt","multiplyMatrices","i","l","length","intersect","object","push"],"sources":["C:/Users/abhin/Desktop/sugam-portfolio/node_modules/@react-three/drei/helpers/Position.js"],"sourcesContent":["import * as THREE from 'three';\n\nconst _instanceLocalMatrix = /*@__PURE__*/new THREE.Matrix4();\n\nconst _instanceWorldMatrix = /*@__PURE__*/new THREE.Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _mesh = /*@__PURE__*/new THREE.Mesh();\n\nclass Position extends THREE.Group {\n  constructor() {\n    super();\n    this.color = new THREE.Color('white');\n    this.instance = {\n      current: undefined\n    };\n    this.instanceKey = {\n      current: undefined\n    };\n  } // This will allow the virtual instance have bounds\n\n\n  get geometry() {\n    var _this$instance$curren;\n\n    return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;\n  } // And this will allow the virtual instance to receive events\n\n\n  raycast(raycaster, intersects) {\n    const parent = this.instance.current;\n    if (!parent) return;\n    if (!parent.geometry || !parent.material) return;\n    _mesh.geometry = parent.geometry;\n    const matrixWorld = parent.matrixWorld;\n    let instanceId = parent.userData.instances.indexOf(this.instanceKey); // If the instance wasn't found or exceeds the parents draw range, bail out\n\n    if (instanceId === -1 || instanceId > parent.count) return; // calculate the world matrix for each instance\n\n    parent.getMatrixAt(instanceId, _instanceLocalMatrix);\n\n    _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n\n    _mesh.matrixWorld = _instanceWorldMatrix;\n\n    _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n\n    for (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n      const intersect = _instanceIntersects[i];\n      intersect.instanceId = instanceId;\n      intersect.object = this;\n      intersects.push(intersect);\n    }\n\n    _instanceIntersects.length = 0;\n  }\n\n}\n\nexport { Position };\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAE9B,MAAMC,oBAAoB,GAAG,aAAa,IAAID,KAAK,CAACE,OAAO,CAAC,CAAC;AAE7D,MAAMC,oBAAoB,GAAG,aAAa,IAAIH,KAAK,CAACE,OAAO,CAAC,CAAC;AAE7D,MAAME,mBAAmB,GAAG,EAAE;AAE9B,MAAMC,KAAK,GAAG,aAAa,IAAIL,KAAK,CAACM,IAAI,CAAC,CAAC;AAE3C,MAAMC,QAAQ,SAASP,KAAK,CAACQ,KAAK,CAAC;EACjCC,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,KAAK,GAAG,IAAIV,KAAK,CAACW,KAAK,CAAC,OAAO,CAAC;IACrC,IAAI,CAACC,QAAQ,GAAG;MACdC,OAAO,EAAEC;IACX,CAAC;IACD,IAAI,CAACC,WAAW,GAAG;MACjBF,OAAO,EAAEC;IACX,CAAC;EACH,CAAC,CAAC;;EAGF,IAAIE,QAAQA,CAAA,EAAG;IACb,IAAIC,qBAAqB;IAEzB,OAAO,CAACA,qBAAqB,GAAG,IAAI,CAACL,QAAQ,CAACC,OAAO,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGI,qBAAqB,CAACD,QAAQ;EAC1G,CAAC,CAAC;;EAGFE,OAAOA,CAACC,SAAS,EAAEC,UAAU,EAAE;IAC7B,MAAMC,MAAM,GAAG,IAAI,CAACT,QAAQ,CAACC,OAAO;IACpC,IAAI,CAACQ,MAAM,EAAE;IACb,IAAI,CAACA,MAAM,CAACL,QAAQ,IAAI,CAACK,MAAM,CAACC,QAAQ,EAAE;IAC1CjB,KAAK,CAACW,QAAQ,GAAGK,MAAM,CAACL,QAAQ;IAChC,MAAMO,WAAW,GAAGF,MAAM,CAACE,WAAW;IACtC,IAAIC,UAAU,GAAGH,MAAM,CAACI,QAAQ,CAACC,SAAS,CAACC,OAAO,CAAC,IAAI,CAACZ,WAAW,CAAC,CAAC,CAAC;;IAEtE,IAAIS,UAAU,KAAK,CAAC,CAAC,IAAIA,UAAU,GAAGH,MAAM,CAACO,KAAK,EAAE,OAAO,CAAC;;IAE5DP,MAAM,CAACQ,WAAW,CAACL,UAAU,EAAEvB,oBAAoB,CAAC;IAEpDE,oBAAoB,CAAC2B,gBAAgB,CAACP,WAAW,EAAEtB,oBAAoB,CAAC,CAAC,CAAC;;IAG1EI,KAAK,CAACkB,WAAW,GAAGpB,oBAAoB;IAExCE,KAAK,CAACa,OAAO,CAACC,SAAS,EAAEf,mBAAmB,CAAC,CAAC,CAAC;;IAG/C,KAAK,IAAI2B,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG5B,mBAAmB,CAAC6B,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MAC1D,MAAMG,SAAS,GAAG9B,mBAAmB,CAAC2B,CAAC,CAAC;MACxCG,SAAS,CAACV,UAAU,GAAGA,UAAU;MACjCU,SAAS,CAACC,MAAM,GAAG,IAAI;MACvBf,UAAU,CAACgB,IAAI,CAACF,SAAS,CAAC;IAC5B;IAEA9B,mBAAmB,CAAC6B,MAAM,GAAG,CAAC;EAChC;AAEF;AAEA,SAAS1B,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}