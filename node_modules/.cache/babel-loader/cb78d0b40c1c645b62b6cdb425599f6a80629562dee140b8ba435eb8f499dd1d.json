{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nfunction isLight(object) {\n  return object.isLight;\n}\nconst accumulativeContext = /*#__PURE__*/React.createContext(null);\nconst AccumulativeShadows = /*#__PURE__*/React.forwardRef(({\n  children,\n  blend,\n  frames = 40,\n  scale = 10,\n  temporal = false,\n  opacity = 1,\n  alphaTest = 0.65,\n  color = 'black',\n  resolution = 1024,\n  ...props\n}, forwardRef) => {\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const defaultCamera = useThree(state => state.camera);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const count = React.useRef(0);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configureObject(gPlane.current);\n  }, []); // Actual number of frames to render, it must be at least 2 due to the ping/ponging in the lightmap\n\n  if (frames <= 1) frames = 2;\n  let blendFrames = blend === undefined ? frames === Infinity ? 100 : frames : frames;\n  const material = React.useMemo(() => {\n    const mat = Object.assign(new THREE.MeshBasicMaterial({\n      opacity: 0,\n      transparent: true,\n      dithering: true,\n      depthWrite: false,\n      map: plm.progressiveLightMap2.texture\n    }), {\n      uniforms: {\n        ucolor: {\n          value: new THREE.Color(color)\n        },\n        alphaTest: {\n          value: 0\n        }\n      }\n    });\n    mat.onBeforeCompile = shader => {\n      mat.uniforms = shader.uniforms = {\n        ...shader.uniforms,\n        ...mat.uniforms\n      };\n      shader.fragmentShader = shader.fragmentShader.replace(`void main() {`, `uniform vec3 ucolor;\n           uniform float alphaTest;\n           void main() {`);\n      shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', `#include <dithering_fragment>\n           gl_FragColor = vec4(ucolor * gl_FragColor.r * 2.0, max(0.0, (1.0 - gl_FragColor.r / alphaTest)) * opacity);`);\n    };\n    return mat;\n  }, [color]);\n  const [lights, setLights] = React.useState([]);\n  function update(frames = 1) {\n    // Adapt the opacity-blend ratio to the number of frames\n    if (!temporal) {\n      material.opacity = opacity;\n      material.uniforms.alphaTest.value = alphaTest;\n    } else {\n      material.opacity = Math.min(opacity, material.opacity + opacity / blendFrames);\n      material.uniforms.alphaTest.value = Math.min(alphaTest, material.uniforms.alphaTest.value + alphaTest / blendFrames);\n    } // Switch accumulative lights on\n\n    gLights.current.visible = true; // Switch off all other scene lights off, collect their intensities\n\n    const intensities = [];\n    scene.traverse(object => {\n      if (isLight(object)) {\n        intensities.push({\n          object,\n          intensity: object.intensity\n        });\n        object.intensity = 0;\n      }\n    }); // Update the lightmap and the accumulative lights\n\n    for (let i = 0; i < frames; i++) {\n      plm.update(defaultCamera, blendFrames);\n      if (lights) lights.forEach(light => light.update());\n    } // Switch lights off\n\n    gLights.current.visible = false; // Switch scene lights on and restore their intensities\n\n    intensities.forEach(({\n      object,\n      intensity\n    }) => object.intensity = intensity);\n  }\n  function reset() {\n    if (frames !== Infinity) {\n      plm.clear();\n      material.opacity = 0;\n      material.uniforms.alphaTest.value = 0;\n      count.current = 0;\n      update();\n    }\n  } // Expose api, allow children to set itself as the main light source\n\n  const api = React.useMemo(() => ({\n    reset,\n    update,\n    setLights\n  }), []);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  useFrame(() => {\n    if (temporal && count.current < frames) {\n      update();\n      count.current++;\n    }\n  });\n  React.useLayoutEffect(() => {\n    reset();\n    if (!temporal) update(blendFrames);\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    material: material,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null)));\n});\nconst RandomizedLight = /*#__PURE__*/React.forwardRef(({\n  castShadow = true,\n  bias = 0,\n  mapSize = 512,\n  size = 5,\n  near = 0.5,\n  far = 500,\n  frames = 1,\n  position = [0, 0, 0],\n  radius = 1,\n  amount = 8,\n  intensity = 1,\n  ambient = 0.5,\n  ...props\n}, forwardRef) => {\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [ambient, length]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    if (parent) parent.setLights(state => [...state, api]);\n    return () => parent.setLights(state => state.filter(a => a !== api));\n  }, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n}); // Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\n\nclass ProgressiveLightMap {\n  constructor(renderer, scene, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.scene.background = null;\n    this.buffer1Active = false; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.uvMat = new THREE.MeshPhongMaterial({\n      shininess: 0,\n      specular: new THREE.Color('black')\n    });\n    this.uniforms = {};\n    this.uvMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_LIGHTMAP\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = shader.fragmentShader.replace('#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n');\n      shader.fragmentShader = 'varying vec2 vUv2;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n      }`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = {\n        value: this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      this.uniforms = shader.uniforms;\n    };\n  }\n  clear() {\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n  }\n  configureObject(object) {\n    const uv2 = object.geometry.getAttribute('uv').clone();\n    object.geometry.setAttribute('uv2', uv2);\n    object.geometry.getAttribute('uv2').needsUpdate = true;\n  }\n  update(camera, blendWindow = 100) {\n    // Set each object's material to the UV Unwrapped Surface Mapping Version\n    this.uniforms.averagingWindow = {\n      value: blendWindow\n    };\n    this.scene.overrideMaterial = this.uvMat; // Ping-pong two surface buffers for reading/writing\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    this.renderer.setRenderTarget(activeMap);\n    this.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.scene.overrideMaterial = null;\n    this.renderer.setRenderTarget(null);\n  }\n}\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };","map":{"version":3,"names":["_extends","THREE","React","useThree","useFrame","isLight","object","accumulativeContext","createContext","AccumulativeShadows","forwardRef","children","blend","frames","scale","temporal","opacity","alphaTest","color","resolution","props","gl","state","scene","defaultCamera","camera","gPlane","useRef","gLights","count","plm","useState","ProgressiveLightMap","useLayoutEffect","configureObject","current","blendFrames","undefined","Infinity","material","useMemo","mat","Object","assign","MeshBasicMaterial","transparent","dithering","depthWrite","map","progressiveLightMap2","texture","uniforms","ucolor","value","Color","onBeforeCompile","shader","fragmentShader","replace","lights","setLights","update","Math","min","visible","intensities","traverse","push","intensity","i","forEach","light","reset","clear","api","useImperativeHandle","createElement","ref","Provider","receiveShadow","rotation","PI","RandomizedLight","castShadow","bias","mapSize","size","near","far","position","radius","amount","ambient","length","Vector3","parent","useContext","useCallback","l","random","set","MathUtils","randFloatSpread","lambda","acos","phi","cos","abs","sin","filter","a","Array","from","_","index","key","attach","args","constructor","renderer","res","background","buffer1Active","format","test","navigator","userAgent","HalfFloatType","FloatType","progressiveLightMap1","WebGLRenderTarget","type","uvMat","MeshPhongMaterial","shininess","specular","vertexShader","slice","bodyStart","indexOf","previousShadowMap","averagingWindow","setRenderTarget","uv2","geometry","getAttribute","clone","setAttribute","needsUpdate","blendWindow","overrideMaterial","activeMap","inactiveMap","render"],"sources":["C:/Users/abhin/Desktop/sugam-portfolio/node_modules/@react-three/drei/core/AccumulativeShadows.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\n\nfunction isLight(object) {\n  return object.isLight;\n}\n\nconst accumulativeContext = /*#__PURE__*/React.createContext(null);\nconst AccumulativeShadows = /*#__PURE__*/React.forwardRef(({\n  children,\n  blend,\n  frames = 40,\n  scale = 10,\n  temporal = false,\n  opacity = 1,\n  alphaTest = 0.65,\n  color = 'black',\n  resolution = 1024,\n  ...props\n}, forwardRef) => {\n  const gl = useThree(state => state.gl);\n  const scene = useThree(state => state.scene);\n  const defaultCamera = useThree(state => state.camera);\n  const gPlane = React.useRef(null);\n  const gLights = React.useRef(null);\n  const count = React.useRef(0);\n  const [plm] = React.useState(() => new ProgressiveLightMap(gl, scene, resolution));\n  React.useLayoutEffect(() => {\n    plm.configureObject(gPlane.current);\n  }, []); // Actual number of frames to render, it must be at least 2 due to the ping/ponging in the lightmap\n\n  if (frames <= 1) frames = 2;\n  let blendFrames = blend === undefined ? frames === Infinity ? 100 : frames : frames;\n  const material = React.useMemo(() => {\n    const mat = Object.assign(new THREE.MeshBasicMaterial({\n      opacity: 0,\n      transparent: true,\n      dithering: true,\n      depthWrite: false,\n      map: plm.progressiveLightMap2.texture\n    }), {\n      uniforms: {\n        ucolor: {\n          value: new THREE.Color(color)\n        },\n        alphaTest: {\n          value: 0\n        }\n      }\n    });\n\n    mat.onBeforeCompile = shader => {\n      mat.uniforms = shader.uniforms = { ...shader.uniforms,\n        ...mat.uniforms\n      };\n      shader.fragmentShader = shader.fragmentShader.replace(`void main() {`, `uniform vec3 ucolor;\n           uniform float alphaTest;\n           void main() {`);\n      shader.fragmentShader = shader.fragmentShader.replace('#include <dithering_fragment>', `#include <dithering_fragment>\n           gl_FragColor = vec4(ucolor * gl_FragColor.r * 2.0, max(0.0, (1.0 - gl_FragColor.r / alphaTest)) * opacity);`);\n    };\n\n    return mat;\n  }, [color]);\n  const [lights, setLights] = React.useState([]);\n\n  function update(frames = 1) {\n    // Adapt the opacity-blend ratio to the number of frames\n    if (!temporal) {\n      material.opacity = opacity;\n      material.uniforms.alphaTest.value = alphaTest;\n    } else {\n      material.opacity = Math.min(opacity, material.opacity + opacity / blendFrames);\n      material.uniforms.alphaTest.value = Math.min(alphaTest, material.uniforms.alphaTest.value + alphaTest / blendFrames);\n    } // Switch accumulative lights on\n\n\n    gLights.current.visible = true; // Switch off all other scene lights off, collect their intensities\n\n    const intensities = [];\n    scene.traverse(object => {\n      if (isLight(object)) {\n        intensities.push({\n          object,\n          intensity: object.intensity\n        });\n        object.intensity = 0;\n      }\n    }); // Update the lightmap and the accumulative lights\n\n    for (let i = 0; i < frames; i++) {\n      plm.update(defaultCamera, blendFrames);\n      if (lights) lights.forEach(light => light.update());\n    } // Switch lights off\n\n\n    gLights.current.visible = false; // Switch scene lights on and restore their intensities\n\n    intensities.forEach(({\n      object,\n      intensity\n    }) => object.intensity = intensity);\n  }\n\n  function reset() {\n    if (frames !== Infinity) {\n      plm.clear();\n      material.opacity = 0;\n      material.uniforms.alphaTest.value = 0;\n      count.current = 0;\n      update();\n    }\n  } // Expose api, allow children to set itself as the main light source\n\n\n  const api = React.useMemo(() => ({\n    reset,\n    update,\n    setLights\n  }), []);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  useFrame(() => {\n    if (temporal && count.current < frames) {\n      update();\n      count.current++;\n    }\n  });\n  React.useLayoutEffect(() => {\n    reset();\n    if (!temporal) update(blendFrames);\n  });\n  return /*#__PURE__*/React.createElement(\"group\", props, /*#__PURE__*/React.createElement(\"group\", {\n    traverse: () => null,\n    ref: gLights\n  }, /*#__PURE__*/React.createElement(accumulativeContext.Provider, {\n    value: api\n  }, children)), /*#__PURE__*/React.createElement(\"mesh\", {\n    receiveShadow: true,\n    ref: gPlane,\n    material: material,\n    scale: scale,\n    rotation: [-Math.PI / 2, 0, 0]\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null)));\n});\nconst RandomizedLight = /*#__PURE__*/React.forwardRef(({\n  castShadow = true,\n  bias = 0,\n  mapSize = 512,\n  size = 5,\n  near = 0.5,\n  far = 500,\n  frames = 1,\n  position = [0, 0, 0],\n  radius = 1,\n  amount = 8,\n  intensity = 1,\n  ambient = 0.5,\n  ...props\n}, forwardRef) => {\n  const gLights = React.useRef(null);\n  const length = new THREE.Vector3(...position).length();\n  const parent = React.useContext(accumulativeContext);\n  const update = React.useCallback(() => {\n    let light;\n\n    if (gLights.current) {\n      for (let l = 0; l < gLights.current.children.length; l++) {\n        light = gLights.current.children[l];\n\n        if (Math.random() > ambient) {\n          light.position.set(position[0] + THREE.MathUtils.randFloatSpread(radius), position[1] + THREE.MathUtils.randFloatSpread(radius), position[2] + THREE.MathUtils.randFloatSpread(radius));\n        } else {\n          let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n          let phi = 2 * Math.PI * Math.random();\n          light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n        }\n      }\n    }\n  }, [ambient, length]);\n  const api = React.useMemo(() => ({\n    update\n  }), [update]);\n  React.useImperativeHandle(forwardRef, () => api, [api]);\n  React.useLayoutEffect(() => {\n    if (parent) parent.setLights(state => [...state, api]);\n    return () => parent.setLights(state => state.filter(a => a !== api));\n  }, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: gLights\n  }, props), Array.from({\n    length: amount\n  }, (_, index) => /*#__PURE__*/React.createElement(\"directionalLight\", {\n    key: index,\n    castShadow: castShadow,\n    \"shadow-bias\": bias,\n    \"shadow-mapSize\": [mapSize, mapSize],\n    intensity: intensity / amount\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    attach: \"shadow-camera\",\n    args: [-size, size, size, -size, near, far]\n  }))));\n}); // Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\n\nclass ProgressiveLightMap {\n  constructor(renderer, scene, res = 1024) {\n    this.renderer = renderer;\n    this.res = res;\n    this.scene = scene;\n    this.scene.background = null;\n    this.buffer1Active = false; // Create the Progressive LightMap Texture\n\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;\n    this.progressiveLightMap1 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new THREE.WebGLRenderTarget(this.res, this.res, {\n      type: format\n    }); // Inject some spicy new logic into a standard phong material\n\n    this.uvMat = new THREE.MeshPhongMaterial({\n      shininess: 0,\n      specular: new THREE.Color('black')\n    });\n    this.uniforms = {};\n\n    this.uvMat.onBeforeCompile = shader => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader = '#define USE_LIGHTMAP\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv2 - 0.5) * 2.0, 1.0, 1.0); }'; // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n\n      const bodyStart = shader.fragmentShader.indexOf('void main() {');\n      shader.fragmentShader = shader.fragmentShader.replace('#include <clipping_planes_pars_fragment>', '#include <clipping_planes_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n');\n      shader.fragmentShader = 'varying vec2 vUv2;\\n' + shader.fragmentShader.slice(0, bodyStart) + '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv2).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n      }`; // Set the Previous Frame's Texture Buffer and Averaging Window\n\n      shader.uniforms.previousShadowMap = {\n        value: this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      this.uniforms = shader.uniforms;\n    };\n  }\n\n  clear() {\n    this.renderer.setRenderTarget(this.progressiveLightMap1);\n    this.renderer.clear();\n    this.renderer.setRenderTarget(this.progressiveLightMap2);\n    this.renderer.clear();\n  }\n\n  configureObject(object) {\n    const uv2 = object.geometry.getAttribute('uv').clone();\n    object.geometry.setAttribute('uv2', uv2);\n    object.geometry.getAttribute('uv2').needsUpdate = true;\n  }\n\n  update(camera, blendWindow = 100) {\n    // Set each object's material to the UV Unwrapped Surface Mapping Version\n    this.uniforms.averagingWindow = {\n      value: blendWindow\n    };\n    this.scene.overrideMaterial = this.uvMat; // Ping-pong two surface buffers for reading/writing\n\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1; // Render the object's surface maps\n\n    this.renderer.setRenderTarget(activeMap);\n    this.uniforms.previousShadowMap = {\n      value: inactiveMap.texture\n    };\n    this.buffer1Active = !this.buffer1Active;\n    this.renderer.render(this.scene, camera);\n    this.scene.overrideMaterial = null;\n    this.renderer.setRenderTarget(null);\n  }\n\n}\n\nexport { AccumulativeShadows, RandomizedLight, accumulativeContext };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}